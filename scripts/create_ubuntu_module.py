#!/usr/bin/env python3
"""
Ubuntu Module Creator for OSv

This script helps create new OSv modules based on Ubuntu packages.
It generates the necessary Makefile, JSON configuration, and module.py files.

Usage:
    create_ubuntu_module.py --name myapp --packages pkg1,pkg2 [options]
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import List

def create_makefile(module_name: str, module_dir: Path) -> None:
    """Create Makefile for the module"""
    makefile_content = f"""# Ubuntu package-based module for {module_name}
# Generated by create_ubuntu_module.py

SRC = $(shell readlink -f $(dir $(lastword $(MAKEFILE_LIST))))
OSV_ROOT = $(SRC)/../..
UBUNTU_PACKAGES_SCRIPT = $(OSV_ROOT)/scripts/ubuntu_packages.py

# Configuration
ARCH ?= amd64
UBUNTU_RELEASE ?= focal

# Output directory for this module
MODULE_DIR = $(OSV_BUILD_PATH)/modules/{module_name}

.PHONY: module clean

module: $(MODULE_DIR)/usr.manifest

$(MODULE_DIR)/usr.manifest: $(SRC)/{module_name}.json
	@echo "Building {module_name} module using Ubuntu packages..."
	@mkdir -p $(MODULE_DIR)
	@$(UBUNTU_PACKAGES_SCRIPT) \\
		--config $(SRC)/{module_name}.json \\
		--output-dir $(MODULE_DIR) \\
		--arch $(ARCH) \\
		--ubuntu-release $(UBUNTU_RELEASE)
	@echo "$(MODULE_DIR)/usr.manifest: $(MODULE_DIR)/usr.manifest" > $(OSV_BUILD_PATH)/usr.manifest
	@if [ -f $(MODULE_DIR)/cmdline ]; then \\
		cp $(MODULE_DIR)/cmdline $(OSV_BUILD_PATH)/cmdline; \\
	fi

clean:
	@rm -rf $(MODULE_DIR)
"""
    
    makefile_path = module_dir / 'Makefile'
    with open(makefile_path, 'w') as f:
        f.write(makefile_content)
    print(f"Created {makefile_path}")

def create_config_file(module_name: str, module_dir: Path, packages: List[str], 
                      cmdline: str = None, extra_blacklist: List[str] = None) -> None:
    """Create JSON configuration file for the module"""
    
    # Default blacklist
    default_blacklist = [
        "bash", "dash", "systemd", "systemd-sysv", "init", "upstart",
        "udev", "systemd-udev", "dbus", "dbus-x11", "apt", "dpkg", 
        "debconf", "perl-base", "python3-minimal", "mount", "util-linux",
        "coreutils", "findutils", "grep", "sed"
    ]
    
    if extra_blacklist:
        default_blacklist.extend(extra_blacklist)
    
    config = {
        "packages": packages,
        "blacklist": default_blacklist,
        "transformations": {
            "remove_files": [
                "*.a", "*.la", "*.pyc", "*.pyo"
            ],
            "remove_directories": [
                "usr/share/doc", "usr/share/man", "usr/share/info",
                "usr/share/lintian", "usr/share/locale", "var/lib/dpkg",
                "var/cache", "etc/init.d", "etc/systemd", "lib/systemd"
            ]
        },
        "manifest_prefix": "/usr"
    }
    
    if cmdline:
        config["cmdline"] = cmdline
    
    config_path = module_dir / f'{module_name}.json'
    with open(config_path, 'w') as f:
        json.dump(config, f, indent=4)
    print(f"Created {config_path}")

def create_module_py(module_name: str, module_dir: Path, cmdline: str = None) -> None:
    """Create module.py file for OSv integration"""
    
    if cmdline:
        module_content = f"""from osv.modules import api

# Default application for {module_name}
default = api.run('{cmdline}')
"""
    else:
        module_content = f"""from osv.modules import api

# Module for {module_name}
# Add your application configuration here
# Example:
# default = api.run('/usr/bin/your-command')
"""
    
    module_py_path = module_dir / 'module.py'
    with open(module_py_path, 'w') as f:
        f.write(module_content)
    print(f"Created {module_py_path}")

def create_readme(module_name: str, module_dir: Path, packages: List[str]) -> None:
    """Create README file for the module"""
    
    readme_content = f"""# {module_name.title()} Module

This OSv module provides {module_name} functionality using Ubuntu packages.

## Packages Included

{chr(10).join(f'- {pkg}' for pkg in packages)}

## Building

To build this module:

```bash
./scripts/build image={module_name}
```

## Configuration

The module configuration is defined in `{module_name}.json`. You can modify:

- `packages`: List of Ubuntu packages to include
- `blacklist`: Packages to exclude from dependency resolution
- `transformations`: File/directory transformations to apply
- `cmdline`: Default command line for the application

## Customization

Edit `{module_name}.json` to customize the package selection and transformations.
Edit `module.py` to customize the OSv application behavior.
"""
    
    readme_path = module_dir / 'README.md'
    with open(readme_path, 'w') as f:
        f.write(readme_content)
    print(f"Created {readme_path}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Create a new OSv module based on Ubuntu packages',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Create a simple curl module
  create_ubuntu_module.py --name curl-app --packages curl --cmdline "/usr/bin/curl --help"

  # Create a web server module
  create_ubuntu_module.py --name nginx-app --packages nginx-core,nginx-common --cmdline "/usr/sbin/nginx -g 'daemon off;'"

  # Create a development tools module
  create_ubuntu_module.py --name devtools --packages gcc,make,git --no-cmdline
        """)
    
    parser.add_argument('--name', '-n', required=True,
                       help='Name of the module to create')
    parser.add_argument('--packages', '-p', required=True,
                       help='Comma-separated list of Ubuntu packages')
    parser.add_argument('--cmdline', '-c',
                       help='Default command line for the application')
    parser.add_argument('--no-cmdline', action='store_true',
                       help='Do not set a default command line')
    parser.add_argument('--extra-blacklist',
                       help='Additional packages to blacklist (comma-separated)')
    parser.add_argument('--modules-dir', type=Path,
                       help='Modules directory (default: ./modules)')
    
    args = parser.parse_args()
    
    # Determine modules directory
    if args.modules_dir:
        modules_dir = args.modules_dir
    else:
        # Assume we're in OSv root or scripts directory
        script_dir = Path(__file__).parent
        if script_dir.name == 'scripts':
            modules_dir = script_dir.parent / 'modules'
        else:
            modules_dir = Path.cwd() / 'modules'
    
    if not modules_dir.exists():
        print(f"Error: Modules directory {modules_dir} does not exist")
        return 1
    
    # Create module directory
    module_dir = modules_dir / args.name
    if module_dir.exists():
        print(f"Error: Module directory {module_dir} already exists")
        return 1
    
    module_dir.mkdir()
    print(f"Created module directory: {module_dir}")
    
    # Parse packages
    packages = [pkg.strip() for pkg in args.packages.split(',')]
    
    # Parse extra blacklist
    extra_blacklist = []
    if args.extra_blacklist:
        extra_blacklist = [pkg.strip() for pkg in args.extra_blacklist.split(',')]
    
    # Determine command line
    cmdline = None
    if not args.no_cmdline:
        cmdline = args.cmdline
    
    # Create files
    try:
        create_makefile(args.name, module_dir)
        create_config_file(args.name, module_dir, packages, cmdline, extra_blacklist)
        create_module_py(args.name, module_dir, cmdline)
        create_readme(args.name, module_dir, packages)
        
        print(f"\\nSuccessfully created module '{args.name}'")
        print(f"\\nTo build the module:")
        print(f"  ./scripts/build image={args.name}")
        print(f"\\nTo customize the module:")
        print(f"  Edit {module_dir}/{args.name}.json")
        print(f"  Edit {module_dir}/module.py")
        
        return 0
        
    except Exception as e:
        print(f"Error creating module: {e}")
        # Clean up on error
        if module_dir.exists():
            import shutil
            shutil.rmtree(module_dir)
        return 1

if __name__ == '__main__':
    sys.exit(main())